% game24 - Solves a game 24 scenario
% Copyright (C) 2020 Tim Gesthuizen <tim.gesthuizen@yahoo.de>
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <https://www.gnu.org/licenses/>.

\documentclass[11pt,a4paper]{article}
\author{Tim Gesthuizen}
\title{Game 24}
\usepackage{tikz}
\usetikzlibrary{trees,fit,arrows,positioning,shapes.geometric}
\usepackage{listings}
\usepackage[a4paper,bindingoffset=0.2in,%
  left=1in,right=1in,top=1in,bottom=1in,%
  footskip=.4in]{geometry}
\usepackage{mathptmx}
\setlength\parindent{0px}
\usepackage{hyperref}
\usepackage{xcolor}
\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}
\usepackage{listings}
\lstdefinelanguage{scheme}
{
  morekeywords={car, cdr, cons, lambda, define, if, when, let},
  morecomment=[l]{;;},
  morestring=[b]",
  frame = single,
  keepspaces = true,
}
\lstalias{shell}{sh}
\definecolor{comment-green}{rgb}{0,0.6,0}
\definecolor{linenumber-gray}{rgb}{0.5,0.5,0.5}
\definecolor{string-mauve}{rgb}{0.58,0,0.82}
\lstset{
  backgroundcolor=\color{white},
  basicstyle=\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  escapeinside={\%*}{*)},
  extendedchars=true,
  frame=single,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  rulecolor=\color{black},
  showspaces=false,
  showstringspaces=true,
  showtabs=false,
  stepnumber=5,
  tabsize=4,
  title=\lstname
}
% colors
\lstset{
  commentstyle=\color{comment-green},
  keywordstyle=\color{blue},
  numberstyle=\tiny\color{linenumber-gray},
  stringstyle=\color{string-mauve}
}


\begin{document}

\maketitle

\tableofcontents

\section{Problem description}

A program shall be written that solves the \textit{Game of 24}.
In this game you are given 4 numbers and need to come up with a
selection of the 4 arithmetic operators $+$, $-$, $\cdot$ and $\div$ to
reduce these numbers to the number 24.
The numbers can be rearranged in any order and the order of the
operations can also be manipulated.
See figure~\ref{fig:trees} for examples of syntax trees.

\input{tikz/syntax-trees.inc}
\input{tikz/syntax-tree-construction.inc}

\section{Problem analysis}

The problem is to construct all possible syntax trees and evaluate
them systematically.
Selecting the operators is not difficult:
We have a set $Operators = \{+, -, \cdot, \div\}$ and generate all
permutations of a multi-set $M$ such that $\vert M \vert = 3$.
\newcommand{\complexop}{{\vert Operators \vert}^3}
\newcommand{\opconnect}{4 \cdot 3 \cdot 3 \cdot 2 \cdot 2 \cdot 1}
This results in $\complexop$ combinations of
operators.

To create a syntax tree from the four operands and the three operators
we use the following algorithm:
Move the seven nodes of the tree into an array, where the four
numbers are placed in front of the three operators.
Now construct an arena from which the operator inputs can be
choosen. The initial bounds of the arena are $[0, 4)$.
The first operator two ``wire up'' will be array entry 4, at the end
of the arena.
Now repeat the following steps for all operators:
\begin{enumerate}
  \item Connect the left hand side of the operator with one of the
    elements in the arena. Swap the selected element to the last
    element in the arena and shrink the end of it by one.
  \item Connect the right hand side of the operator with one of the
    elements in the arena. Swap the operator with the selected
    operand. This is done as the operator is now fully connected and
    can be used as an input for the following operators.
\end{enumerate}
If the algorithm is executed as described here, at the end the first
element of the array will always be the root node of the tree. In the
implementation the last swap is omitted so that the root node of the
tree is always the last node.
In the implementation the operators use indices into the array to
refer to their left and right hand side operands. This means that
swapping the actual elements of the array will break the referencing
of the operator nodes.
Therefore an extra indirection is used where the indices of the real
nodes are stored in an array of indicis and only the indices in the
array are swapped.
Through this indirection it is possibly to virtually swap elements in
the array without changing the physical arrangement of the nodes in
memory.
Find an example of this algorithm in figure~\ref{fig:treecon}.

Given this algorithm the total number of different syntax tree
``forms'' is $\opconnect$.
There are $\complexop \cdot \opconnect = 11664$ different syntax trees
that need to be checked as a consequence.

\section{Design of the first iteration of the program}

The user enters the four numbers the program shall find solutions
for. The program then calculates all permutations and builds up the
syntax trees for them. If a syntax tree evaluates to 24, it is
printed.
It should be noted that all of this can be done in $\mathcal{O}(1)$
space.
The above requirements result in the following software parts:
\begin{enumerate}
\item {\tt main} and user interactions
\item Syntax tree creation and permutation
\item Syntax tree evaluation
\item Syntax tree printing
\end{enumerate}

\section{Code of the first iteration of the program}

\lstinputlisting[language=C]{iteration1.c}

\section{Problems with the first iteration}

The first iteration of the program does very well. On Tim Gesthuizens
laptop the program takes a little bit longer than a tenth of a second
to run.
Surprisingly, as shows in figure \ref{fig:opt-info-it1}, GCC is able to
fold most of the code into the \textit{main} function.
Even the indirect call of \textit{iterateAllSyntaxTrees} to
\textit{checkAndPrintCallback} is detected and inlined.
As shown in figure \ref{fig:perfit1}, the hottest part of the program
is the evaluation of syntax trees.
As expected the compiler was not able to inline the two recursive
functions that traverse the binary trees, therefore they are quite
slow.
As the time spent in \textit{evalSyntaxTree} is only around $50\%$,
the maximal speedup possible by optimizing it is around $\times 2$.

While the first iteration of the program does what was asked for it
does it in a very ugly way. E.g. the output for the numbers $2$ $2$ $3$ $9$
is
\begin{verbatim}
((2 * 9) + (2 * 3))
((2 * 3) + (2 * 9))
((2 * 9) + (3 * 2))
((3 * 2) + (2 * 9))
((2 * 3) + (9 * 2))
((9 * 2) + (2 * 3))
((2 * 9) + (2 * 3))
((2 * 3) + (2 * 9))
((2 * 3) + (2 * 9))
((2 * 9) + (2 * 3))
((3 * 2) + (2 * 9))
((2 * 9) + (3 * 2))
((2 * 3) + (2 * 9))
((2 * 9) + (2 * 3))
((9 * 2) + (2 * 3))
((2 * 3) + (9 * 2))
((3 * 2) + (2 * 9))
((2 * 9) + (3 * 2))
((3 * 2) + (9 * 2))
((9 * 2) + (3 * 2))
((2 * 9) + (3 * 2))
((3 * 2) + (2 * 9))
((9 * 2) + (3 * 2))
((3 * 2) + (9 * 2))
...
\end{verbatim}

While these are unique solutions to a computer they look like the same
solution to a human. This is because the computer does not know about
the associativity and commutativity of the $+$ and $\cdot$
operations.

We can solve this issue in two ways:
\begin{enumerate}
\item \label{opt:rewrite} Rewrite part of the generation routine to
  omit redundant trees
\item \label{opt:filter} Filter the trees after the generation for
  duplicates
\end{enumerate}

Option \ref{opt:rewrite} might be the faster version, but it has
several drawbacks:
\begin{itemize}
\item It makes the already complex code for tree generation more
  complex
\item The \textit{iterateAllSyntaxTrees} function does one thing,
  adding another thing (filtering) would violate the single
  responsibility principle.
  This function should be changed when there is a change to how trees
  are generated, not when new shortcuts in evaluation are discovered.
\end{itemize}

\begin{figure}[h]
  \centering
  \begin{lstlisting}
  Samples: 24  of event 'cycles:u', Event count (approx.): 3584609
    Children      Self  Command  Shared Object     Symbol
  +   83.22%     0.00%  game24   game24            [.] _start
  +   83.22%     0.00%  game24   libc-2.31.so      [.] __libc_start_main
  +   83.22%    29.23%  game24   game24            [.] main
  +   78.44%     0.00%  game24   game24            [.] iterateAllSyntaxTrees (inlined)
  +   49.21%     0.00%  game24   game24            [.] checkAndPrintCallback (inlined)
  +   48.43%    48.43%  game24   game24            [.] evalSyntaxTree
  +    9.27%     0.00%  game24   ld-2.31.so        [.] _start
  +    9.14%     0.39%  game24   ld-2.31.so        [.] _dl_start
  +    8.91%     0.00%  game24   game24            [.] swap (inlined)
  \end{lstlisting}
  \caption[Perf recording for iteration one]{Excerpt of the perf
    recording of a run of the first iteration program}
  \label{fig:perfit1}
\end{figure}

\begin{figure}[h]
  \centering
  \begin{lstlisting}
  ~/src/game24/build$ gcc -fopt-info -O2 ../game24.c -o game24
  ../game24.c:123:11: optimized:  Inlining compareOps/29 into iterateAllSyntaxTrees/30.
  ../game24.c:153:7: optimized:  Inlining swap/28 into iterateAllSyntaxTrees/30.
  ../game24.c:151:7: optimized:  Inlining swap/28 into iterateAllSyntaxTrees/30.
  ../game24.c:148:7: optimized:  Inlining swap/28 into iterateAllSyntaxTrees/30.
  ../game24.c:146:7: optimized:  Inlining swap/28 into iterateAllSyntaxTrees/30.
  ../game24.c:143:7: optimized:  Inlining swap/28 into iterateAllSyntaxTrees/30.
  ../game24.c:141:7: optimized:  Inlining swap/28 into iterateAllSyntaxTrees/30.
  ../game24.c:58:61: optimized:  Inlining makeInvalid/23 into evalSyntaxTree/24.
  ../game24.c:58:29: optimized:  Inlining makeNumber/22 into evalSyntaxTree/24.
  ../game24.c:56:14: optimized:  Inlining makeNumber/22 into evalSyntaxTree/24.
  ../game24.c:54:14: optimized:  Inlining makeNumber/22 into evalSyntaxTree/24.
  ../game24.c:52:14: optimized:  Inlining makeNumber/22 into evalSyntaxTree/24.
  ../game24.c:48:14: optimized:  Inlining makeInvalid/23 into evalSyntaxTree/24.
  ../game24.c:43:12: optimized:  Inlining makeNumber/22 into evalSyntaxTree/24.
  ../game24.c:77:5: optimized:   Inlining putchar/5 into printSyntaxTreeImpl/25 (always_inline).
  ../game24.c:73:5: optimized:   Inlining putchar/5 into printSyntaxTreeImpl/25 (always_inline).
  ../game24.c:82:3: optimized:   Inlining putchar/5 into printSyntaxTree/26 (always_inline).
  ../game24.c:155:7: optimized: converting indirect call in iterateAllSyntaxTrees.constprop/54 to direct call to checkAndPrintCallback/31
  ../game24.c:123:38: optimized:  Inlined incrementOperators/27 into iterateAllSyntaxTrees.constprop/54 which now has time 174325.022705 and size 116, net change of -9.
  ../game24.c:155:7: optimized:  Inlined checkAndPrintCallback/55 into iterateAllSyntaxTrees.constprop/54 which now has time 182150.243408 and size 126, net change of +10.
  ../game24.c:164:5: optimized:  Inlined printSyntaxTree/56 into checkAndPrintCallback/55 which now has time 183683.494385 and size 16, net change of +4.
  ../game24.c:164:5: optimized:  Inlined printSyntaxTree/26 into checkAndPrintCallback/31 which now has time 22.030000 and size 20, net change of -6.
  ../game24.c:132:7: optimized: loop with 2 iterations completely unrolled (header execution count -1856307904)
  ../game24.c:108:3: optimized: loop with 2 iterations completely unrolled (header execution count 1743412647)
  \end{lstlisting}
  \caption[GCC opt-info, iteration 1]{GCC optimization info for the
    first iteration program}
  \label{fig:opt-info-it1}
\end{figure}

\end{document}